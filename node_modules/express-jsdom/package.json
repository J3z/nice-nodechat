{
  "name": "express-jsdom",
  "version": "0.0.1",
  "description": "Server-side DOM for express",
  "homepage": "https://github.com/fgnass/express-jsdom",
  "author": {
    "name": "Felix Gnass",
    "email": "felix.gnass@neteye.de",
    "url": "http://fgnass.posterous.com"
  },
  "keywords": [
    "express",
    "jsdom",
    "jquery"
  ],
  "directories": {
    "lib": "./lib/express-jsdom"
  },
  "main": "./lib/express-jsdom.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/fgnass/express-jsdom.git"
  },
  "dependencies": {
    "jsdom": "0.2.0",
    "html5": "0.2.14",
    "express": "2.2.0",
    "mime": ">=0.0.1",
    "socket.io": "0.6.17",
    "uglify-js": ">=0.0.1",
    "stylus": ">=0.0.1"
  },
  "devDependencies": {
    "tobi": "0.1.1"
  },
  "readme": "The express-jsdom module provides an alternative approach to building web applications with [express](http://expressjs.com/).\n\nInstead of using templates to create markup, it uses the same object model as the browser to build documents. Once the document has been assembled on the server, it is serialized and sent to the client as HTML.\n\nExample\n=======\n\n    var express = require('express'),\n        app = express.createServer(),\n        dom = require('express-jsdom')(app);\n\n    dom.get('/hello', function(document) {\n        document.title = 'Hello World';\n    });\n\nJQuery Support\n==============\n\nWith express-jsdom you may also use your [jQuery](http://jquery.com/) skills on the server:\n\n    dom.use('jquery');\n    \n    dom.get('/hello', function($) {\n        $('body').append('<h1>Hello world</h1>');\n    });\n\nSeamless Event Handling\n=======================\n\nThe best thing about having a server-side representation of the client's DOM is that it allows you to handle browser events on the server. The browser then opens a websocket connection which is used to keep the server and client side DOM in sync.\n\nThe server can subscribe to any client-side event. When such an event is dispatched on the client, it is forwarded to the server where it gets re-dispatched. All modifications made to the server-side DOM are captured and replayed on the client.\n\n    dom.get('/', 'relay', function($) {\n    \n      $('<h1>Hello</h1>')\n        .appendTo('body')\n        .relay('click', function() {\n          $(this).after(\"<h2>world</h2>\");\n        });\n\n      $('h2').liveRelay('click', function() {\n        $(this).remove();\n      });\n      \n    });\n\nDOM Aspects\n===========\n\nBefore we go into detail with server-side event handling, let's take a look at some basic concepts. A big advantage of having a server-side DOM is that it allows you to horizontally separate crosscutting concerns. In express-jsdom this is done using _aspects_, which are similar to connect's middleware stack, as they provide common functionality that can be either globally applied or on a per-route basis.\n\n    dom.use(foo); // Global Aspect\n  \n    // Route Aspects\n    dom.get('/', bar, baz, function(document) {\n      //...\n    });\n\nAspects may be defined in several ways. The simplest form of an aspect is a function with an arbitrary argument list. The arguments are populated _by name_, hence `function(window)`, `function(document)`, `function(req, window, $)`, `function($)` are all valid signatures.\n\nCommonly used groups of aspects can be passed as an array:\n\n    var a = [aspect1, aspect2],\n      b = [aspect3, aspect4],\n      all = [a, b];\n\n    dom.get('/', a, aspect3, function(){});\n    dom.get('/', a, b, function(){});\n    dom.get('/', all, function(){});\n    \nNote that also the last function argument, which usually contains the route-specific logic, is nothing else but an _inline aspect_.\n\nAnother way to define an aspect is to create an object with an _apply_ method. This is useful for more complex aspects with dependencies, or aspects that provide assets.\n\nAspect Dependencies\n===================\n\nEach aspect may define dependencies to other aspects. Here's an example that depends on the built-in _jquery_ aspect to set a target on all absolute links so that they are opened in a new window: \n\n    module.exports = {\n      depends: 'jquery',\n      apply: function($) {\n        $('a[href^=http]').attr('target', '_blank');\n      }\n    };\n\nMultiple dependencies can be specified using an array:\n\n    module.exports = {\n      depends: ['jquery', require('./bar'), 'foo'],\n      apply: function($) {\n        // ...\n      }\n    };\n\nIn an aspect is specified using a string, express-jsdom uses the directory of the file that declares the dependency to resolve the given string to an absolute path which is then loaded with `require()`.\n\nAsset Management\n================\n\nAn aspect may also define assets like client-side JavaScripts or stylesheets.\n\n    dom.use({css: 'assets/default.css'});\n    \nThis will include `default.css` in all pages. The built-in asset manager does not only inject a link tag into the document's head, it also handles the serving of the referenced file. You can also use [stylus](http://learnboost.github.com/stylus/), [less](http://lesscss.org/) or [sass](http://sass-lang.com/) to preprocess the stylesheet. To do so, just give your file the appropriate extension:\n\n    dom.use({css: 'assets/default.styl'});\n\nAn aspect to load jQuery UI could look like this:\n\n    module.exports = {\n      depends: 'jquery',\n      js: 'assets/jquery-ui-1.8.11.js',\n      css: 'assets/jquery-ui-18.11.custom.css'\n    };\n\nWe could also use the [Google-hosted CDN version](http://code.google.com/apis/libraries/devguide.html#jqueryUI) with a fallback to our local copy:\n\n    module.exports = {\n      depends: 'jquery',\n      js: {\n        file: 'assets/jquery-ui-1.8.11.js',\n        cdn: '//ajax.googleapis.com/ajax/libs/jqueryui/1.8.11/jquery-ui.min.js',\n        test: 'jQuery.ui'\n      },\n      css: 'assets/jquery-ui-18.11.custom.css'\n    };\n\nParsing HTML Documents\n======================\n\nIn the previous examples the complete documents were built programmatically. Instead of building the whole DOM from scratch, you may also parse an existing HTML file.\n\n    dom.get('/', dom.parse('/home.html'), function() {})\n    \nThis will load `<baseDir>/views/home.html`. If the file you want to load equals the route-mapping, you can also write:\n\n    dom.get('/home', dom.parse, function() {})\n    \n__Note:__ If the path doesn't contain a dot, _dom.parse_ will append `.html` as file extension.\n\nJQuery Event Relay\n==================\n\nLet's take a closer look at the _seamless events_ example from above: \n\n    dom.get('/', 'relay', function($) {\n\n      $('<h1>Hello</h1>')\n        .appendTo('body')\n        .relay('click', function() {\n          $(this).after(\"<h2>world</h2>\");\n        });\n\n      $('h2').liveRelay('click', function() {\n        $(this).remove();\n      });\n  \n    });\n\nThe built-in _relay_ aspect provides the jQuery `.relay()` plugin, which calls `.bind()` on the client to register an event handler that forwards the event to the server via a websocket.\n    \nIn out example, every time the `<h1>` element is clicked, a new `<h2>` is inserted on the server. The resulting server-side DOM mutation event is captured and translated into a jQuery DOM mutation function: `$('h1').after('<h2>world</h2>')`. This operation is sent back to the client via the websocket connection where it gets executed.\n\nThere's a second plugin method called `.liveRelay()` which does a similar thing, but instead of calling [`.bind()`](http://api.jquery.com/bind/) it uese jQuery's [`.live()`](http://api.jquery.com/live/) method to register the event handler. This way clicks to all newly inserted `<h2>` element are also automatically forwarded to the server. \n\nAsynchronous Responses\n======================\n\nYou may use `res.defer()` to defer the response until all callbacks have been invoked. Here's an example that calls two async functions to build the document:\n\n    dom.get('/', function(document, res) {\n      fs.realpath(__filename, res.defer(function(err, resolvedPath) {\n        document.title = resolvedPath;\n      }));\n      fs.readdir(__dirname, res.defer(function(err, files) {\n        document.body.innerHTML = files.join('<br>');\n      }));\n    });\n\nCalling `res.defer(fn)` returns a proxy function that delegates all calls to _fn_. All proxies have to be invoked in order to send the response to the client. Calling the same proxy twice will throw an error.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/fgnass/express-jsdom/issues"
  },
  "_id": "express-jsdom@0.0.1",
  "dist": {
    "shasum": "c6db68e745fee118dc97cf2d6aeed3e16a4a6abb"
  },
  "_from": "express-jsdom@",
  "_resolved": "https://registry.npmjs.org/express-jsdom/-/express-jsdom-0.0.1.tgz"
}
